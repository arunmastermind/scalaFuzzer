object i0 {
implicit class I1(val I1: Any) {
def I1(I2: String): I1 = I2.I1(I1)
def unapply(I3: Int) = 0
}
trait I4 {
type I2 <: I1
type I3 = Int
def I4: AnyRef = I2
}
trait I4 extends (I3 {
trait I4 {
abstract override def I1 = new I1.toList
}
}
class I2 extends {
val I1 = 4
def I1: Int = { I2 { object I3 I4 => } class I2 { def I1: List[i0] = None
def update(I4: I1) = () } type I4 <: String { var I2: Int = 10 }
val I3 = I1
val I4 = 2
I1 1
}
def I2: collection.reflect.I1.I1
}
}