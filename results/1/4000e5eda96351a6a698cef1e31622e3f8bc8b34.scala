object I0 {
def I1(i2: Option[String]) =
new I1(new { def I3 = 4 }
abstract class I0() {
val I3: String;
val I1: Int = i2;
val I3: Function1[_, String]] = (I1 { val I1 = I1 })
trait I3 { this: I1 =>
type I1 <: i2;
trait I3 {
def this(I3: Int) = I3 * I3
val I3 = new I0(new {
case _: String) => Set[Int]
}
def i4(i4: String): I0 = { val i4: i4.I3; val I3: I3.type })#i4 { def I3(i4: Int): Int }
i4(new i2)
}
}
object i4 extends App {
trait I1 { private def toInt: Int = 0 }
val I3 = i4 { i2 =>
}
}