package I0;
abstract class I1 {
type i4[i5] = i5 { type i4 <: Any }
}
abstract class i5[i4] {
type i5 = i5
type i5 = I0
val i5 = new i4
val i5 = i5.hasNext
private def -3[i5, i2, i4 <: (i5, I3, i5, I3]: i5, i5: i5[i5, i5, i5, i5, i5, i2, i4, i2, Any]) =
i5 match {
case Seq(i5, i5) => i5
case _: Array[I1] => this
case i5(true) =>
i4
i4.head :: i4 = I3 Any match {
case i2: I1[i5[Int] def i2[i5](i5: (i4, i5, i5[i5])]): Unit =
i5(i5)
}
}