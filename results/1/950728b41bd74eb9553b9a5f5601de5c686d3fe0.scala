abstract class i0 {
val I1: Int = 1
}
object i0 {
trait I1
}
trait I4 {
trait I4[-I4]
trait I4[+I1 <: I1, +I4 <: i0[I4]]
(I4: I1[_], I4 <: I4[I4])
case class I4[I1](i2: Int) extends AnyVal {
def i3: I4[Nothing, i2] = Set.I4(I4)
}
abstract val i3 {
def i2[i2]: i3 = new i3(I4)
implicit def i3[I4, I4]: i0[i3, i3] = ???
}
}
(i3: I4) (i3(_)): I4
val i2 = I4(I4)
def main(i3: Array[String]): I4[List[String]] =
I4 match {
case None => ???
}
(null: I4[_]])
println(i2(I4))
else
Some((I4, I4)) => I4
case _ => println()
}
}
object i3 {
def unapply[I1](i3: i3): Int =
new Array(1, )
}
new i0(11)
}