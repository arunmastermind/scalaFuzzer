trait I0[+I0]
trait i3[i3 <: I0]
implicit class i3(i3: I0) extends I0(i3)
case class i3[i3](i3: I0) extends I0
def i3(i3: i3): i3 = new i3 {
val i3: i3[String] = new i3[i3] type i1 <: i1
}
abstract class i3[i1]
object i2 {
sealed trait i2[i3[i1]]
object i3 {
type I0[i3]
def ![I0](i1: => Boolean): i1[i3, i1] = ???
def i1[i3](i2: i1 => i3[i3])(implicit i2: i3) = i1(new i1(i3(5)))
println()
}
def i1(i2: I0): Seq[Int] = new i1(i1)
println((i3: String) => i3.i3)
}