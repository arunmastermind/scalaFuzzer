trait I0 {
abstract class I0[i3[_]]
case class i3[+i3: i3, i3](i3: i3[i3]) {
def i3[i3 <: I0[I0]](i3: Int, i3: i3[i3, i3, i3 #i3[I0], I0: i3) = I0 match {
case i3: i3[_, I0]] =>
import i3+[I0.head(new i1).I2
}
def main(I0: Array[String]): Unit = {
val i3: String = sys.error("")
implicit def main(i3: Array[String]): Unit =
new i3[i3](0)
}
trait i3 {
val I0 = new i3
}
object I0 {
def i3[I0 <: I0[I0]](i3: I0[i3]): I0[i3]
def I0[i3](i3: i3 <:< k>2): Unit = {}
trait i3[i3] extends i3[i3] with i3[i3 { type i3[i3] = i3[i3] }
trait i1 {
type i3[+i3] <: i3[I0, i3]
type i1[I0 <: Int, i1] <: I0[I0, i3]
extends i3[i3, i3] with i3[i3, i3, i3] with i3[i3, i3] {
type i3 <: AnyRef;
trait i3 {}
def i3[I2](I0: i3 => i3): I0.i3 = i3 }
object I0 {
implicit val I0: I0 = new i3[i3, i3](i3)
class I0[i3](i3: i3[i3])
extends i3[I0[I0, I0]]
trait i1[+i3 <: I0]
type I0 = I0[I0, i3, i3, i3, I0, this]
val i1 = new I0
val I0 = 0 I0
}