abstract class i0[Double]
object i0 {
trait i1[i3]
trait List[i3]
trait i3[i3]
trait i4[i1[_], i3]
trait i4[+i3] extends super[i0, [i3, i3[Double]]]
trait i4[+i3] trait i4
trait i4
class i4[+i3]
class i4[i3: i4]
object i3 {
def i3[i3, i3 <: i0[i3]]: i3[i4] = new i3[i3] {}
}
}
object i4 {
val i4: Int = 0
}
private object i4 extends i3 {
type i3 = (i4 with i3)
val i4 = i3
i4.i4 == i3
def i4(i3: Int): Array[i3] = i1
def i4(i3: Array[Array[Byte], Int]) = i1() def i1(i4: i4.i1[Any]): Unit = i4 match {
case i3(None, val i4: Int, i4: Int): Int = i1
class i3(i3: Int, i4: String): Unit = i1 println(I2[Int])
}