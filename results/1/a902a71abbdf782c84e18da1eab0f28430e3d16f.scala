abstract class i0 {
val i1: Int = 1
}
object i0 {
trait i1
}
trait i5 {
trait i5[-i5]
trait i5[+i1 <: i1, +i5 <: i0[i5]]
(i5: i1[_], i5 <: i5[i5])
case class i5[i1](i2: Int) extends AnyVal {
def i5: i5[Nothing, i2] = Set.i5(i5)
}
abstract val i5 {
def i2[i2]: i5 = new i5(i5)
implicit def I4[i5, i5]: i0[i3, I4] = ???
}
}
(I4: i5) (i3(_)): i5
val i2 = i5(i5)
def main(i3: Array[String]): i5[List[String]] =
i5 match {
case None => ???
}
(null: i5[_]])
println(i2(i5))
else
Some((i5, i5)) => i5
case _ => println()
}
}
object I4 {
def unapply[i1](i3: i3): Int =
new Array(1, )
}
new i0(11)
}