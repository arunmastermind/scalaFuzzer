package i0;
abstract class I1 {
type I4[I4] = I4 { type I4 <: Any }
}
abstract class I4[I4] {
type I4 = I4
type I4 = i0
val I4 = new I4
val I4 = I4.hasNext
private def -3[I4, I2, I4 <: (I4, i3, I4, i3]: I4, I4: I4[I4, I4, I4, I4, I4, I2, i3, I2, Any]) =
I4 match {
case Seq(I4, I4) => I4
case _: Array[I1] => this
case I4(true) =>
i3
i3.head :: i3 = i3 Any match {
case I2: I1[I4[Int] def I2[I4](I4: (I4, I4, I4[I4])]): Unit =
I4(I4)
}
}