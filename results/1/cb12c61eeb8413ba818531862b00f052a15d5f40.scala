object App {
class for {
}
def I1: String =
}
trait i3 {
trait i3
type i3 = { type i3 <: i3.i3; type i3 = i3 } = null }
trait i3 {
type i3
def i3(i3: I1): I1 = throw super.i3
}
}
import i3._
implicit class i3: Int extends I0
object i3 extends i3
sealed abstract class i3 {
val i3: I1
val i3 = 
val i3 = i3
i3(i3)
}
}
abstract class I1 extends i3 {
val i3: i3 = ???
}
object I1 {
}
object I1 extends I0
case class I1() {
val i3 = new I1 { type i3 = i3.i3 }
type I1 = i3#i
val i3 = null
implicit def i3: i3 = i3.i3 val I1: i3.i3 = null; var I1: I1.I1 = ???
val I1: i3 = null
implicit def I1[i3] = Some(I1).i3 i3.i3
implicit def I1 = i3 match {
case _: i3 => ???
}
(('i3: Int) <=< i2)
}