object i0 {
trait i0 {
type I3
def I3[I3](I3: I3) = {}
trait I3[I3] {
def I3(I3: List[I3], I3: Any): Int = I3 + I3
}
implicit def I3[i0](I3: => Ordered[i0]) = I2 + I1
}
sealed abstract class I2[+I2] {
def I3[i0]()(implicit I3: i0*) = I2 match {
case I1(I1) =>
val I2: I3[Int] = I3
implicit true
I3[String,
Double
List[i0[Any]]
}
}