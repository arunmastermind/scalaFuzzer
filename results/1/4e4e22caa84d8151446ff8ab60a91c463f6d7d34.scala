trait i0 {
def i0: {}
implicit def i3[i4, i4](i4: String): i4 = ???
val i4 = Nil
?[Option]
i4 i4 (_ < 2)
val i4 = 1 =  i4 match {
case i4 => 1
case `i4` => }
def map[i4](implicit i4: Int, i4: i0)(implicit i4: i4[String]): List[i3] = sys.error("")
class i4[i4](val I1: i4) extends i0
class i4[i0](I2: i0, )(val I2: I2)
object i0 {
type i0[+i3] = (i3, i4)
trait I1 extends super[i0, i3] {
def I1[i4: i4, i4](i4: i4 => i4) = ???
implicit def I2(I2: i0): Unit val i4 = new i0 {
private val i4: Int = 0
def toString[i0[I1]](I1: String, I2: I1*) = i4 match {
case i0(i4(i4)) => I2 += 1 }
}
trait i0 {
i4(i3 => i4)
final def apply[i4, I1](I2: Int => Int) = i4(I1, I2)
}
i3(i4 ::: Nil
I2: I2)
}
}