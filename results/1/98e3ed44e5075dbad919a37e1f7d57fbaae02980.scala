object i0 {
def i1(i2: Option[String]) =
new i1(new { def i2 = 4 }
abstract class i0() {
val I3: String;
val i1: Int = i2;
val i2: Function1[_, String]] = (i1 { val i1 = i1 })
trait I3 { this: i1 =>
type i1 <: i2;
trait i2 {
def this(I3: Int) = i2 * I3
val I4 = new i0(new {
case _: String) => Set[Int]
}
def i5(i5: String): i0 = { val i5: i5.i2; val I3: I4.type })#i5 { def i2(i5: Int): Int }
i5(new i2)
}
}
object i5 extends App {
trait i1 { private def toInt: Int = 0 }
val I3 = i5 { i2 =>
}
}