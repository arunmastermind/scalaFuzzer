object I0 {
implicit class i1(val i2: Any) {
def i2(i2: String): i1 = i2.i1(i2)
def unapply(i3: Int) = 0
}
trait i3 {
type i2 <: i1
type i3 = Int
def i3: AnyRef = i2
}
trait i4 extends (i3 {
trait i4 {
abstract override def i2 = new i2.toList
}
}
class i2 extends {
val i1 = 4
def i2: Int = { i2 { object i3 i3 => } class i2 { def i1: List[I0] = None
def update(i4: i2) = () } type i3 <: String { var i2: Int = 10 }
val i3 = i2
val i3 = 2
i2 1
}
def i2: collection.reflect.i2.i1
}
}