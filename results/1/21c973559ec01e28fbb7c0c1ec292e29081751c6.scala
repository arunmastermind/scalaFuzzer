abstract class I0[Double]
object I0 {
trait i1[i1]
trait List[I2]
trait I2[i1]
trait I2[i1[_], i1]
trait i3[+i1] extends super[I0, [i1, i1[Double]]]
trait i3[+i1] trait I2
trait i3
class i3[+i1]
class i3[i1: i3]
object i1 {
def I2[i1, I2 <: I0[I2]]: I2[I2] = new I2[I2] {}
}
}
object i3 {
val i3: Int = 0
}
private object i3 extends i1 {
type I2 = (I2 with I2)
val i3 = i1
i3.i3 == I2
def i3(I2: Int): Array[i1] = i1
def i3(I2: Array[Array[Byte], Int]) = i1() def i1(I2: I2.i1[Any]): Unit = i3 match {
case I2(None, val i3: Int, I2: Int): Int = i1
class I2(I2: Int, I2: String): Unit = i1 println(i1[Int])
}