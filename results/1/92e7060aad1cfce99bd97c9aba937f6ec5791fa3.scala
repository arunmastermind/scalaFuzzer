class i0 {
sealed trait i1
}
trait i6 {
object i6 extends i1
object i6
val i6 = null
val i6: i1.type = i6
val i6: i0.i1 = new i6, { def i6 = "" }
case class i6(i6: i6) extends i6 {
abstract class i1 extends i6.map(i6.i6);
case val i1: i6;
type i6 <: I5;
trait i6 extends i3 {
def i3
}
val i6: i0 = null;
private var i6: i6;
def i3(I5: i6.i6) = i6 def I5(I5: i1): i6 <: i6.i6
}
object i2 extends i0 {
private val i1: Int = 1 }
}
package class i6() {
type i3 <: i1;
val i6: i6;
var i2: i1;
def I5(implicit i3: i1): Int = I5 *
}
import i0.i1
trait i2 {
object I5 {
class i1 }
object i6 {}
}
class i6{
}
object i2
trait i6 {
type i6[i6]
val i6: String;
type i3 = i6
}
trait i6 extends i6 {
def i6: List[i1] = i6.i6
}
abstract class i1 { i6: i6 =>
type i6 = i6.i6
}
object i6 {
import i1._ import i6.I5 { val i1 = sys.error(""); i3 }
new i0 {
trait i2 {
type i6
type i6 <: i6;
type i4 = i6 new i6
val i6 = i6;
i6 + 1 i6 <
i6;
i6 <i6>{} match
}
}
}
}