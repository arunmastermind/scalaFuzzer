object i0 {
trait i0 {
type i3
def i4[i5](i5: i3) = {}
trait i5[i5] {
def i3(i5: List[i5], i5: Any): Int = i5 + i3
}
implicit def i5[i0](i5: => Ordered[i0]) = i0 + i0
}
sealed abstract class I2[+I1] {
def i5[i0]()(implicit i5: i0*) = I1 match {
case i0(i0) =>
val i0: i5[Int] = i5
implicit true
i4[String,
Double
List[i0[Any]]
}
}