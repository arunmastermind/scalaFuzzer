object i0 {
trait i0
def i3: i0 = new i0
implicit def i3(i3: i0): i3 = new i0 {
type i3 = List[String]
}
abstract class i3 {
def i0 =
val i3: Int
}
class i3 {
val i3 = new i3 { type i3 = String; val i3: i0.i3 = this; i3.i3 } def i3: i3 = i3 match {
case _: Array[String] => null
implicit def i0(i3: Int) = i3 + i0
i3 i0 match {
case i3(i3) => i0.i3
}
lazy val i2: Any = i0 }
}
class i0 {
def i0 = new i3 {
def i3(i3: String) = i3 match {
case Some(i3) => }
}
object i0 {
def main(I1: Array[String]): Unit = {
val i0 = new i0
i3(1)
}
}
object i2 extends i3 {
trait i0
val i3 = i0
val i0 = i0
val i3 = new i3
def I1 = new i0("")
}
}