object i0 {
trait i0 {
type I1
def I1[I2](I2: I1) = {}
trait I2[I2] {
def I1(I2: List[I2], I2: Any): Int = I2 + I1
}
implicit def I2[i0](I2: => Ordered[i0]) = i0 + i0
}
sealed abstract class I1[+i0] {
def I2[i0]()(implicit I2: i0*) = i0 match {
case i0(i0) =>
val i0: I2[Int] = I2
implicit true
I1[String,
Double
List[i0[Any]]
}
}