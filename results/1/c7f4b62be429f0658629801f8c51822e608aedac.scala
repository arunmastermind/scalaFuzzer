package i0
object i0 {
class I3[I3]
implicit val I3: I3
}
case object I3 extends i0[match {
type I3[I3] <: i0[I3, I3]]
def I3[I3 <: I3](implicit I3: I3)(erased I3: I3): I3[I3] = new I3[I3.type]
}
trait I3[I3 <: Any with I3] with I3[I3, I3, I3], I3 <: Long] {
val I3: i0[Class, I3] = List()
}
abstract class I3[i0 <: I3, I1- I3, I3[I3, I1, I1], I3] = I3[I3, I3 <: I3, I3, I3](I3, I3, I3, I3, I3, I3, I3, I3, I3, I3, I3, I3, I3, I3, I3, i0, I3, I3, I3, I3, I3 k1091, I3, I3, I3, I3, I2, I3, I3, I3] => I3) =
(I1, I1.I1) I3(I3(I3)) }
}
class I3(val I3: I3{I3})
val I3: I3 = { implicit val I3: I3 = ??? }
(null: List[AnyRef]) match {
case _ => super.I3.I3
}
}
object I3 {
import i0[I3]
}