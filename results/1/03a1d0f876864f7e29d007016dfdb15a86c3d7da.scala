object i0 {
trait i0
def I5: i0 = new i0
implicit def I5(I5: i0): I5 = new i0 {
type I5 = List[String]
}
abstract class I5 {
def i0 =
val I5: Int
}
class I5 {
val I5 = new I5 { type I5 = String; val I5: i0.I5 = this; I5.I5 } def I5: I5 = I5 match {
case _: Array[String] => null
implicit def i2(I5: Int) = I5 + i1
I5 i1 match {
case I5(I5) => i2.I5
}
lazy val I5: Any = i1 }
}
class i1 {
def i2 = new I5 {
def I5(I5: String) = I5 match {
case Some(I5) => }
}
object i2 {
def main(I3: Array[String]): Unit = {
val i2 = new i0
I5(1)
}
}
object I4 extends I5 {
trait i2
val I5 = i1
val i2 = i0
val I5 = new I5
def I3 = new i1("")
}
}