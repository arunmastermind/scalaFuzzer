trait I0 {
abstract class I0[I3[_]]
case class I3[+I3: I3, I3](I3: I3[I3]) {
def I3[I3 <: I0[i1]](I3: Int, I3: I3[I3, I3, I3 #I3[i1], i1: I3) = i2 match {
case I3: I3[_, I0]] =>
import I3+[i2.head(new i2).I3
}
def main(i2: Array[String]): Unit = {
val I3: String = sys.error("")
implicit def main(I3: Array[String]): Unit =
new I3[I3](0)
}
trait I3 {
val i1 = new I3
}
object I0 {
def I3[I0 <: I0[I0]](I3: I0[I3]): I0[I3]
def i1[I3](I3: I3 <:< k>2): Unit = {}
trait I3[I3] extends I3[I3] with I3[I3 { type I3[I3] = I3[I3] }
trait i2 {
type I3[+I3] <: I3[i2, I3]
type i2[i2 <: Int, I3] <: i2[i2, I3]
extends I3[I3, I3] with I3[I3, I3, I3] with I3[I3, I3] {
type I3 <: AnyRef;
trait I3 {}
def I3[I3](i2: I3 => I3): i2.I3 = I3 }
object I0 {
implicit val i2: i1 = new I3[I3, I3](I3)
class i1[I3](I3: I3[I3])
extends I3[i1[I0, I0]]
trait I3[+I3 <: I0]
type i2 = I0[I0, I3, I3, I3, i2, this]
val i2 = new I0
val i2 = 0 i2
}