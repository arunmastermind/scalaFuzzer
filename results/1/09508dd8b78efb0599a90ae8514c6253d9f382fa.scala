trait i0 {
def I1: {}
implicit def i4[i6, i6](i6: String): i6 = ???
val i6 = Nil
?[Option]
i6 i6 (_ < 2)
val i6 = 1 =  i6 match {
case i6 => 1
case `i6` => }
def map[i6](implicit i6: Int, i6: i0)(implicit i6: i6[String]): List[i4] = sys.error("")
class i6[i6](val i2: i6) extends i0
class i6[I1](i2: I1, )(val i2: i2)
object i0 {
type I1[+i4] = (i4, i6)
trait i2 extends super[i0, i4] {
def i2[i6: i6, i6](i6: i6 => i6) = ???
implicit def i2(i3: I1): Unit val i6 = new I1 {
private val i6: Int = 0
def toString[i0[i2]](i2: String, i2: i2*) = i6 match {
case i0(i6(i6)) => i2 += 1 }
}
trait i0 {
i6(i5 => i6)
final def apply[i6, i2](i3: Int => Int) = i6(i2, i3)
}
i4(i6 ::: Nil
i2: i2)
}
}