object i0 {
case class i1[I4](I4: i1)
case class I4(I4: Int) extends AnyVal with i1
val I4 = Nil
implicit def I4[I4](I4: i0[_]) =
{
new I4
println(I4(1))
}
object I4 {
def apply[I4](I4: => I4): I4 = new I4({ val I4: i0[String, String] = () } def I4[I4](I4: String): with[I4] = I4 match {
case _: I4[Any] => false
case i3: Array[Boolean] => I4.map +  + 1
case _ => println(i1)
}
new I4[Boolean] {
val I4 = new i0 {
val I2 = i1(false);
if (true) I2(I2) }
class I2 extends I4 { def ===(i3: Int)(I4: I4) extends super[i0, String] var I4 = _; new I4() }