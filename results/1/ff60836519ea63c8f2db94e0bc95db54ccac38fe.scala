object i0 {
def I1[i5, i5](i5: i5)(implicit i5: Float[i5], i5: i5[i5]): I1[i5] = I2
}
object i4 {
val I1[i5, i5, i5[i5 <: i5]] { type i5[i5] = (I1, i5) } = i5
}
}
trait i5 extends i5[Int] {
type I2 = Int
def i5(i5: i5): i5[i5] = new i5[i5] {
def I2(i5: I1[i5]): Unit = i5 }
abstract class i3[Float]
class i3 extends i5[i5, Seq] {
val i3 = new i5[Int];
val i3 = new i5(i5);
val i5 = i5.i5(i5 + 1))
}