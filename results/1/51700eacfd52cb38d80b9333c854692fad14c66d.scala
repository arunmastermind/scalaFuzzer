trait I0 {
protected def i1
}
object i3 {
val i3: I0
}
object i3 {
class i3
sealed trait i3 extends i3 {
type i3 <: i3
type i3
}
abstract class i3[i3 <: i3] extends i1 {
type i3 <: i3 with i3
type i1 <: i3;
trait I2 { () => i3 }
}
abstract class I2 extends i3 {
trait i1
}
val i3: I2 { type i3 = i3; type i1 = i3 }
type i3 = i3 => { val i3 =  }
object i3 {
def I2[i1, I2](i3: i3): i1[I2, List[i3]] = i3[i3, i3] i3.i3
}
class I2 {
val i3 = new i3[Int] {}
}
object i3 {
import I0._
import i3.i3
new i3
}
def I2 = i3[I2, i3]()
implicit def i3[i3, i3 <: Int](i3: i3[i3]): i3 = i3
def i3[i3 >: i3](implicit i3: i1, i3: i3<i3): I2[I2[i3 <: Seq[i3]], I2] = I2.i3
}