abstract class i0[Double]
object i0 {
trait i0[I1]
trait List[I1]
trait I2[I1]
trait i3[i0[_], I1]
trait i4[+I1] extends super[i0, [I1, I1[Double]]]
trait i4[+I1] trait i3
trait i4
class i4[+I1]
class i4[I1: i4]
object I1 {
def I1[I1, I1 <: i0[I2]]: I2[i3] = new I2[I1] {}
}
}
object i4 {
val i4: Int = 0
}
private object i4 extends I1 {
type I1 = (i3 with I2)
val i4 = I1
i4.i4 == I1
def i4(I2: Int): Array[I1] = i0
def i4(I2: Array[Array[Byte], Int]) = i0() def i0(i3: i3.i0[Any]): Unit = i4 match {
case I1(None, val i4: Int, i3: Int): Int = i0
class I2(I2: Int, i3: String): Unit = i0 println(I1[Int])
}