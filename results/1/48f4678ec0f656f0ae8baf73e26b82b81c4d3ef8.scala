package I0;
abstract class I0;
trait I4 {
trait I4;
trait I4 extends I0 {
type I4 <: I4;
trait I4 {
type I4
val I4: I4 = ???
}
val I4: I4.I4 = { val I4 = this; I4 }
val I4: I0 { val I4: I4.I4 };
I4.I4 }
val I4 = new I4() {
val I1: I4 = null
implicit def I1: I0 = new I4 {}
implicit def I4 = new I4(1)
implicit def I1(i2: Int): Int = I4
type I4 = { case i3(I0, i3) => i3 }
val I4 = I1 def I4: Int = I1(i2)
}
trait I1 {
type i2 = I4
type i3 <: I0 <: I0
final val I1: I4.I4 = null;
val I1: (I0.I4, Seq[I4]]) =
val I4 = i3() i3 i3.I4(I1)
def I4(I1: Seq[I0]): Unit = {}
}
trait I4 extends I0 {
abstract override def I4 = super.I0
def I4 = I4.I4;
val I4: I4.I4 = I4.I4
}