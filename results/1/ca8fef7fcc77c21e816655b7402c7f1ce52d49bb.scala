object I0 {
type i1
type i4 = { val i4: I0 } = null;
val i4: I0 = i4;
var i4: i1.i4;
val i4: i4.i1
}
trait i4 {
def i4(i4: i4): Unit Array def i1(i4: Int = i4): Unit =
i4.i1();
def i1() = i1;
def i3(i2: i1): i1.i4 = i4
}
object i3 {
val i2: i4.i1
}
implicit class i4()
val i4 = i4
val i1 = new i4.i1(2)
def i1(i1: String = ): Unit = {
val i4 = new i4();
val i4 = i1(i4);
val i2: I0.i1 = true
final val i1 = i1.i4
def i4(i2: Int) = i1 + i2(i2)
implicit val i1 = new i1()
}
}
import type i3 {
def i3 : i1;
type i2 <: i1;
def i4: i1;
}
}
object i3 {
implicit def i4(i1: i4): Any = i4(I0);
}
class i4 extends i4 {
private def i1() = this.i4()
}
class i1 extends i4 with i4 {
val i1 = i1(i4);
println()
case i4 @ List() => println()
}
}
class i1 extends i1 {
def i4: Unit = i4;
def i4: List[i4] = i1
type i2 = List[i4]
type i3 = i2; type i2 = i2; type i2 <: i1; }
}
trait i1 extends i4 { i4: i4 }
val i4 = new i4(???)(i4, i4)
def i4(i1: i1): I0 = null
implicit def i3(i4: Any): Int = 1
def i3(i2: i4 | i1): i4.i1 = i1 match {
case i1(i4) =>
i4.i4 match {
case i4(i4) => 1
}
var i4 = 0
i4 = i4
val i1 = i4
val i1 = i4.i4()
val i1 = i4
}
val i4 = i1.i3()
i4.collect.i4.i1;
} List {
val i2: Int = i2
}
val i1 = {
super.i1
}
}
}