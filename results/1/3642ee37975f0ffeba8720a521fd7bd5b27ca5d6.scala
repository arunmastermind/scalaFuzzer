abstract class i0 {
val I1: Int = 1
}
object i0 {
trait I1
}
trait I5 {
trait I5[-I5]
trait I5[+I1 <: I1, +I5 <: i0[I5]]
(I5: I1[_], I5 <: I5[I5])
case class I5[I1](I1: Int) extends AnyVal {
def I4: I5[Nothing, I1] = Set.I5(I5)
}
abstract val I5 {
def I1[I1]: I4 = new I4(I5)
implicit def i3[I5, I5]: i0[I2, i3] = ???
}
}
(i3: I5) (I2(_)): I5
val I1 = I5(I5)
def main(I2: Array[String]): I5[List[String]] =
I5 match {
case None => ???
}
(null: I5[_]])
println(I1(I5))
else
Some((I5, I5)) => I5
case _ => println()
}
}
object i3 {
def unapply[I1](I2: I2): Int =
new Array(1, )
}
new i0(11)
}