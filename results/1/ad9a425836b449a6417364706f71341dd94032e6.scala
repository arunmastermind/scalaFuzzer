object App {
class for {
}
def i1: String =
}
trait i3 {
trait i3
type i3 = { type i3 <: i3.i3; type i3 = i3 } = null }
trait i3 {
type i3
def i3(i3: i1): i1 = throw super.i3
}
}
import i3._
implicit class i3: Int extends I0
object i3 extends i3
sealed abstract class i3 {
val i3: i1
val i3 = 
val i3 = i3
i3(i3)
}
}
abstract class i2 extends i3 {
val i3: i3 = ???
}
object i2 {
}
object i2 extends I0
case class i2() {
val i3 = new i1 { type i3 = i3.i3 }
type i2 = i3#i
val i3 = null
implicit def i2: i3 = i3.i3 val i2: i3.i3 = null; var i2: i2.i2 = ???
val i2: i3 = null
implicit def i2[i3] = Some(i2).i3 i3.i3
implicit def i2 = i3 match {
case _: i3 => ???
}
(('i3: Int) <=< i2)
}