trait i0 {
abstract override type i0 <: String
}
def i5[i5] = None
def i5[i5 >: Nothing](i5: List[i0]*) = i5
val i5 = i5.Exception { i5 =>
i5 map i5 :: i5 => i5(i5)
new i5(i5)() def i5[i5 <: i5] = i5.i5(i5);
def 6 = i5();
def i1[i5, i5, i5](i5: i5 => Int) =
(i5, i5) i5 { case i5 => i5(i5.i5); this }
}
abstract class i5 extends i5 {
type I2 <: i5
}
}
sealed class i1[+i0, i5](val i5: i5[i5], i1: i5) extends i5[(i5, i5), I2, i5, i5, i4, i5, i5, i5, I2, i5, i5, i5, i1, i1, i5, i5, i5](
i5, I2,
i3, i5, i4, i5, i5, i3, i4, i5, i5[i0, i5, i5, i4, I2, I2, i3, i4 <: i5, i5, I2, i4 <: i5, i4, i5, i5, i4, i5, i5, i5, i5, i5, i5, i5, Int, i5, i5, i5)(implicit I2: i0[i0, i5, Int]): i3 forSome { type i5[i5, i5] = i5, I2, i5[i5 <: i5, i5[Int]] = i5[i0, i5] }
}
class i1 extends i5[i5] {
def i5: i5[i5] = ???
def i5[i0[_], i5[i5 with[i5[i1]]]
type i5[i5[_, i5] <: i5[i5]#i5]
trait i5
final object i4 extends i0(I2) extends i1
case object i1 extends i1
case class i5() extends i5[i0](I2) {
override protected[this] def i1 = i5[i5](new i5))
}