abstract class i0
object i0 {
implicit def i4(i4: i0 => Int, i4: i4) => Unit = ???
def i4(i4: i0): Unit = val i4: i4
}
abstract class i1[i4, i4](i4: i4) { type i4 <: i0[i4] }
trait i4 extends i4 with i0[i4] trait I3 {
type i2 = { type i4 }
final val i4 = i2(i4 i2 i4 with i0) map (_ => i4)
def i4[i4, i4 <: AnyRef](implicit I3: i4[i4]): Seq[i0[1]], i2: i4[i4]#i1 => i4): i2 = { trait i2 extends i4 forSome { type i4 <: i2; type i4 = i2 }) {
type i0[+i4, @specialized i1]
trait i4[i4]
class i1[i2 <: AnyRef] extends i4[i4]
final case class I3[i4]()
extends i0[i4] with i4[Class[_ <: i4]]
Map[Float]
Null type i4 <: Nothing
final case class i1(i2: String, i2: Int, I3: Int)
object i1 extends i4[i4]
object i2 extends i4
val i4: i4 = ???
implicit def i4(I3: i4): Unit = {}
type i2 = i4[Int]
val i2 = i4[i4]
val i4 extends i4 {
def I3[I3 <: i4[i4]](
implicit i2: i0[i0], i4 <<< i1[i4, i4]](
18 { type i4 <: i2[I3#i4]
type I3[i4] = i1[i4.i4[{i4])
i1[i4] def I3[i4: i4[i4], I3](I3: i0[i4]): i0[i4, i4[Any, i4]] = i1 match {
case val i1: i4[i4] = sys.error("")
}
object i1