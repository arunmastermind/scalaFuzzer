abstract class I0
object i1 {
implicit def i6(i6: i1 => Int, i6: i6) => Unit = ???
def i6(i6: I0): Unit = val i6: i6
}
abstract class I2[i6, i6](i6: i6) { type i6 <: I0[i6] }
trait i6 extends i6 with I0[i6] trait i4 {
type I3 = { type i6 }
final val i6 = I2(i6 I3 i6 with I0) map (_ => i6)
def i6[i6, i6 <: AnyRef](implicit i4: i6[i6]): Seq[i1[1]], I3: i6[i6]#I2 => i6): I3 = { trait I3 extends i6 forSome { type i6 <: I3; type i6 = I2 }) {
type i1[+i6, @specialized I2]
trait i6[i6]
class I2[I2 <: AnyRef] extends i6[i6]
final case class i4[i6]()
extends i1[i6] with i6[Class[_ <: i6]]
Map[Float]
Null type i6 <: Nothing
final case class I2(I2: String, I3: Int, i4: Int)
object I2 extends i6[i6]
object I2 extends i6
val i6: i6 = ???
implicit def i5(i4: i6): Unit = {}
type I2 = i6[Int]
val I2 = i6[i6]
val i5 extends i6 {
def i4[i4 <: i6[i6]](
implicit I2: i1[i1], i6 <<< I2[i6, i6]](
18 { type i5 <: I2[i4#i6]
type i4[i6] = I2[i6.i6[{i6])
I2[i6] def i4[i6: i6[i6], i4](i4: i1[i6]): i1[i6, i6[Any, i6]] = I2 match {
case val I2: i6[i6] = sys.error("")
}
object I2