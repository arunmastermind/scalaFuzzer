package I0;
abstract class i1;
trait I6 {
trait I6;
trait I6 extends i1 {
type I6 <: I6;
trait I6 {
type I6
val I6: I6 = ???
}
val I6: I6.I6 = { val I6 = this; I6 }
val I6: I0 { val I6: I6.I6 };
I6.I6 }
val I6 = new I6() {
val I2: I6 = null
implicit def I2: i1 = new I6 {}
implicit def I6 = new I6(1)
implicit def I2(i3: Int): Int = I6
type I6 = { case I4(i1, I4) => I5 }
val I6 = I2 def I6: Int = I2(i3)
}
trait I2 {
type i3 = I6
type I4 <: i1 <: I0
final val I2: I6.I6 = null;
val I2: (i1.I6, Seq[I6]]) =
val I6 = I4() I4 I5.I6(I2)
def I6(I2: Seq[i1]): Unit = {}
}
trait I6 extends i1 {
abstract override def I6 = super.i1
def I6 = I6.I6;
val I6: I6.I6 = I6.I6
}