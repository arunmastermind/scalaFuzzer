trait I0 {
def I0: {}
implicit def i3[i4, i4](i4: String): i4 = ???
val i4 = Nil
?[Option]
i4 i4 (_ < 2)
val i4 = 1 =  i4 match {
case i4 => 1
case `i4` => }
def map[i4](implicit i4: Int, i4: I0)(implicit i4: i4[String]): List[i3] = sys.error("")
class i4[i4](val I0: i4) extends I0
class i4[I0](I0: I0, )(val i1: I0)
object I0 {
type I0[+i3] = (i3, i4)
trait I0 extends super[I0, i3] {
def I0[i4: i4, i4](i4: i4 => i4) = ???
implicit def I0(I2: I0): Unit val i4 = new I0 {
private val i4: Int = 0
def toString[I0[I0]](I0: String, i1: I0*) = i4 match {
case I0(i4(i4)) => I0 += 1 }
}
trait I0 {
i4(i3 => i4)
final def apply[i4, I0](I2: Int => Int) = i4(I0, I2)
}
i3(i4 ::: Nil
I0: I0)
}
}