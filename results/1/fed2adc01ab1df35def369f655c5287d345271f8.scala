trait I0[+I1, I4] {
type I4[I4] <: I1[I4]
def I4 = super.I4
val I4: Symbol[Int]
}
trait I4[@specialized(Double) I1](val I4: I4) {
type I4 = Unit
}
trait I4[I4 <: AnyRef, I4] {
def I4[I1](implicit I4: I1) = I4
}
sealed class I3 { def main(I4: Array[String]): Unit = () lazy val I4 = I4()
}
object I4 {
implicit def I3[I3[_ <: I0]](implicit I4: I0[I4]): I4
}
trait I4[I1[+I4] <: I0[I1, I4]] {
type I4 <: String
val I2: I1
def I3[I4, I4, I4, I3, I4: I1[_], I4, I4, I3] = I3 =!= I3 =>
I4
}
object I3 {
def apply[I3](I4: I4): Unit = {
lazy val I3 = { case I3 => I4 }
}
object I2 { case class I3[I3, I4](I3: Int) extends I4[I4]
class I3 {
def I3[I4, I4](I3: Int) = null
def I3[I3, I4 <: Singleton](I3: Int): Int = 1
}
abstract class I4 {
def I4: I4
trait I2
type I3 = I3
type I3
type I3
type I3[I4, I4 <: I4, I4 >: I1, I4, I4 <: I4,
I4 <: I4,
I4: I4.I4]
}
object I4 {
trait I1[I4]
final case class I3[I1, I4](I4: I4[I4, I4])
def I4[I4](I4: I2[I2, I3, Int]): Int,
I4: I4[(Int, Int)): Unit = ()
def I3(I3: Option[I3[Int]]) = I4
I4(1)
val I2: I4[I4, I4] = I2(0)
I2(this.I4 == null)
I4 == I4(1, 2)
I2.I4 = I4{I4 }
}
class I3(I4: Int)(val I3: Int)
val I3 = 0
val I4 = I3
val I3 = new I4((I3: Int) => I2) I4"
val I3 = (List(1, 2, 3, 5))
}