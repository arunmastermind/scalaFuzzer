package i0 { import _
abstract class I1[I5]
class I5[I5](I5: I5) {
def unapply(I5 => false): Int = ???
val I5: i0[I5]
}
trait I5 {
type I1[I5 <: I1] = I5[I5]
I5, I5[I5]
}
class I5[I5](val I5: I5) {
implicit def I3[I5[I5](implicit I5: I5[I5]]): Unit }
trait I5[i0, I5, I5] {
def I3[@specialized I5]: I1[I5, I5] = new I5[I1]
}
object i4 {
def I5[I5 <: I5[I5]](I5: I1): I5[I5] = new I1[Int];
type I5[I5] >: I1[I1, I5] <: i0[I1]
type I5 = I1
def i4: I5[Any] = new I5[I5]
def I2[I5](I5: I1[I5]): Nothing = for (I2 < I1 I2 I5(I2) +++ I5I5 ++ I3(I5)
type I3[I1, I2, I5] {}
}
trait I5[I5 <: I5] extends i0[I5, I1]
trait I5 extends I5[I5.I5] trait I2[I3[String]]
implicit def I2[I5](implicit I5: I1[I1], I5: List[_,9reflect[I5]): I3[I5] = null
val I5 = i0[I5]
val i4 = I5[Int]
}
object I5 extends I1[Int]