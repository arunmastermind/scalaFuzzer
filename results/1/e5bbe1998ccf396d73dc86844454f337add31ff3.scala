package I0;
abstract class I0 {
type I3[I3] = I3 { type I3 <: Any }
}
abstract class I3[I3] {
type I3 = I3
type I3 = I0
val I3 = new I3
val I3 = I3.hasNext
private def -3[I3, I1, I3 <: (I3, I1, I3, I1]: I3, I3: I3[I3, I3, I3, I3, I3, I1, I3, I1, Any]) =
I3 match {
case Seq(I3, I3) => I3
case _: Array[I0] => this
case I3(true) =>
I2
I3.head :: I3 = I1 Any match {
case I1: I0[I3[Int] def I1[I3](I3: (I3, I3, I3[I3])]): Unit =
I3(I3)
}
}