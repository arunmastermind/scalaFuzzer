object i0 {
trait I1
def I3: I1 = new I1
implicit def I3(I3: I1): I3 = new I1 {
type I3 = List[String]
}
abstract class I3 {
def I1 =
val I3: Int
}
class I3 {
val I3 = new I3 { type I3 = String; val I3: I1.I3 = this; I3.I3 } def I3: I3 = I3 match {
case _: Array[String] => null
implicit def i2(I3: Int) = I3 + i2
I3 i2 match {
case I3(I3) => i2.I3
}
lazy val I3: Any = i2 }
}
class i2 {
def i2 = new I3 {
def I3(I3: String) = I3 match {
case Some(I3) => }
}
object i2 {
def main(i2: Array[String]): Unit = {
val i2 = new i0
I3(1)
}
}
object I3 extends I3 {
trait i2
val I3 = i2
val i2 = I1
val I3 = new I3
def I3 = new i2("")
}
}