object I0 {
def i1[I5, I5](I5: I5)(implicit I5: Float[I5], I5: I5[I5]): i1[I5] = i1
}
object i4 {
val i1[I5, I5, I5[I5 <: I5]] { type I5[I5] = (i1, I5) } = I5
}
}
trait I5 extends I5[Int] {
type i1 = Int
def I5(I5: I5): I5[I5] = new I5[I5] {
def i1(I5: i1[I5]): Unit = I5 }
abstract class i1[Float]
class i2 extends I5[I5, Seq] {
val I3 = new I5[Int];
val I3 = new I5(I5);
val I5 = I5.I5(I5 + 1))
}