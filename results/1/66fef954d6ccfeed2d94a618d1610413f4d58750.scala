trait i0[+i0]
trait i3[i3 <: i0]
implicit class i3(i3: i0) extends i0(i3)
case class i3[i3](i3: i0) extends i0
def i3(i3: i3): i3 = new i3 {
val i3: i3[String] = new i3[i3] type I2 <: I2
}
abstract class i3[I1]
object I2 {
sealed trait I2[i3[I1]]
object i3 {
type i0[i3]
def ![i0](I1: => Boolean): I1[i3, I1] = ???
def I1[i3](I2: I1 => i3[i3])(implicit I2: i3) = I1(new I1(i3(5)))
println()
}
def I1(I2: i0): Seq[Int] = new I1(I1)
println((i3: String) => i3.i3)
}