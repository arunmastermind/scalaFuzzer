object i0 {
type I1
type I7 = { val I7: i0 } = null;
val I7: i0 = I7;
var I7: I1.I7;
val I7: I7.I1
}
trait I7 {
def I7(I7: I7): Unit Array def I2(I7: Int = I7): Unit =
I7.I1();
def I2() = i3;
def i5(i3: I1): I1.I7 = I7
}
object I4 {
val i3: I7.I1
}
implicit class I6()
val I6 = I7
val I2 = new I7.I2(2)
def I2(i3: String = ): Unit = {
val I6 = new I7();
val I6 = I2(I7);
val i3: i0.I1 = true
final val I2 = I2.I7
def I6(i3: Int) = i3 + i3(i3)
implicit val i3 = new I2()
}
}
import type I4 {
def i5 : I1;
type i3 <: I2;
def I7: I1;
}
}
object I4 {
implicit def I7(i3: I7): Any = I7(i0);
}
class I7 extends I7 {
private def i3() = this.I7()
}
class I2 extends I7 with I7 {
val I2 = I2(I7);
println()
case I7 @ List() => println()
}
}
class I2 extends I2 {
def I7: Unit = I7;
def I7: List[I7] = I2
type i3 = List[I7]
type I4 = i3; type i3 = i3; type i3 <: i3; }
}
trait I2 extends I7 { I7: I7 }
val I7 = new I7(???)(I7, I7)
def I6(i3: I1): i0 = null
implicit def i5(I7: Any): Int = 1
def i5(i3: I7 | i3): I7.I1 = i3 match {
case I2(I7) =>
I7.I7 match {
case I7(I7) => 1
}
var I7 = 0
I7 = I7
val I2 = I7
val I2 = I7.I7()
val i3 = I7
}
val I6 = i3.I4()
I7.collect.I7.I1;
} List {
val i3: Int = i3
}
val i3 = {
super.i3
}
}
}