object I0 {
implicit def I0[I5[_]](I5: I5): I5
}
object I5 {
type I5[I5]] = I5 def I5(I5: I5): I5[I5, I5 =: I5] = sys.error()
lazy val I5 = I5.I5
I5.I5
}
case class I5[I5, I5 <: I0](type I5: I5 { def I5(I0: I5)(implicit i1: I5[I0, String]) = ??? : I5 type I5[I5] = I5[I5]#I0 forSome { type I5 <: I0.I5 }
val i3: (I0, I2) = ???
val I5 = new I5 {}
class I4(I5: Int)
object i1 {
def I5 = new I5[Int] {}
implicit def I0[I5](implicit I5: I5[I0, I5]): I5[I5] = new I5[I5, I5](I5);
object I2 {
def I2(I4: Int = i1): I5 = I2().I5
}
}
object I2 extends I0[I0, I0[I5]] {
def I0(I5: I5): String = i1
}
object I5 {
case class I5(I2: Int) extends AnyVal
trait I0 extends map[Int]
implicitly[Equiv[Int]]]
}
}