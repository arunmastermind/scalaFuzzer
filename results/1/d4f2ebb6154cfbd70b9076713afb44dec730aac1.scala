trait i0 {
abstract override type I1 <: String
}
def i6[i6] = None
def i6[i6 >: Nothing](i6: List[I1]*) = i6
val i6 = i6.Exception { i6 =>
i6 map i6 :: i6 => i6(i6)
new i6(i6)() def i6[i6 <: i6] = i6.i6(i6);
def 6 = i6();
def i2[i6, i6, i6](i6: i6 => Int) =
(i6, i6) i6 { case i6 => i6(i6.i6); this }
}
abstract class i6 extends i6 {
type I3 <: i6
}
}
sealed class i2[+I1, i6](val i6: i6[i6], I3: i6) extends i6[(i6, i6), i4, i6, i6, I5, i6, i6, i6, I3, i6, i6, i6, i2, I3, i6, i6, i6](
i6, i4,
I5, i6, I5, i6, i6, I5, I5, i6, i6[I1, i6, i6, I5, I3, i4, I5, I5 <: i6, i6, I3, I5 <: i6, I5, i6, i6, I5, i6, i6, i6, i6, i6, i6, i6, Int, i6, i6, i6)(implicit I3: i0[I1, i6, Int]): I5 forSome { type i6[i6, i6] = i6, I3, i6[i6 <: i6, i6[Int]] = i6[I1, i6] }
}
class i2 extends i6[i6] {
def i6: i6[i6] = ???
def i6[I1[_], i6[i6 with[i6[i2]]]
type i6[i6[_, i6] <: i6[i6]#i6]
trait i6
final object I5 extends i0(i4) extends I3
case object I3 extends i2
case class i6() extends i6[I1](I3) {
override protected[this] def I3 = i6[i6](new i6))
}