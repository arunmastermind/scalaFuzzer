object i0 {
def i0[I1](implicit I1: i0[I1]) = new i0[Option](I1) }
trait I1 {
type i0[-I1] = i0[I1]
val I1: I1[Int, Int] = sys.error("")
}
class I1[I1 <: I1[I1], I1 <: I1[I1], I1](I1: I1[i0], I1: I1) extends i0[I1, I1] {
def size: i0[I1] = new I1[I1]
def i0[I1 <: Any](I1: i0): Unit =
i0.I1(I1)
}
object I1 {
def I1[I1, I1](I1: I1[i0]): I1[I1, i0]] = I1 match {
case I1(I1) =>
case _ => true
case _: Some[I1] => I1.I1.I1
def I1: i0[i0] => Unit =
i0 match {
case None =>
return 1
case _ => None
}
println(I1 +  + I1)
}
trait I1 {
type i0[I1] = List[I1 { type I1 <: i0[I1] } = null;
val I1: I1[i0, I1] = null
}