object I0 {
def I0(I0: Option[String]) =
new I0(new { def I0 = 4 }
abstract class I0() {
val I1: String;
val I0: Int = I0;
val I0: Function1[_, String]] = (I0 { val I0 = I0 })
trait I1 { this: I0 =>
type I0 <: I0;
trait I0 {
def this(I1: Int) = I0 * I1
val i2 = new I0(new {
case _: String) => Set[Int]
}
def I3(I3: String): I0 = { val I3: I3.I0; val I1: i2.type })#I3 { def I0(I3: Int): Int }
I3(new I0)
}
}
object I3 extends App {
trait I0 { private def toInt: Int = 0 }
val I1 = I3 { I0 =>
}
}