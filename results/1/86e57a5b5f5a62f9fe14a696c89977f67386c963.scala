class i0[+i1] {
def I5[I5, I5, I5, I5 <: i1] = false
def I5(I5: I5[i1]) = null
def I5[I5, I5 <: I5, I5 >: I5](implicitly: I5 <:< I5[I5]): Unit =
(({ () => 0): I5[I5] 5 }
trait I5 { I5 =>
def I5(i1: Array[Seq[I5, _]]) =
if (I2)
0
}
I4(new Object()) new {i3(Int, null)} }
}).asInstanceOf[i0#i1] I5 match {
case _: Array[I5] => implicit I5 => case _ =>
}
}
sealed abstract class I2[I2] {
def I5[I5](I5: => I5=): I5 =
I5 match {
case Seq(I5(2), i1(I2)) => I4.I5(i3.I5[1.head, 1., *, 'I5.I2.I5)
}
}
object i1 {
def unapply(I5: Int) = I2()
def this(I5: => Boolean) = Some(50)
def List[I5](implicit I2: i0[i1]): Unit = {}
def I5[i3[_]](i1: List[I5]): i0[i1] = new I5[I5] {
type I2[+i1] = I5[I5, i1]
val i3: List[i1] = null
val I2: I5[Int]#I5[String, I5[i1]]