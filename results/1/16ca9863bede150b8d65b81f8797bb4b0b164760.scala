package I0
trait I1[I1]
case class I2[I1, I1 <: I1](I2: I2) extends I1[I1]
object I1 extends I1[Int] with I1[I0];
case class I2[I1 <: I0](val I2: Any) extends I0 {
def I2(I2: I0[I2]): List[I0[_]]
implicit def I2 = new I0[Int] {}
def I2[I1: I2] = I2 => I1 + 1
}
object I2 {
I2: (I1, I1) trait I2 extends super.I1 = sys(I1) }
class I2(val I2: Int = 0) {
type I2[I1] = I2[I1]
val I2: Option[(I2, I2)] = I2.I2
val I1: I2[String] = null
val I1 = 0
def I1[@specialized I1](): I1[I2] = (I1) => I2 +
+I2
}