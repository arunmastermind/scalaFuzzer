object I0 {
def I0[I1](implicit I1: I0[I1]) = new I0[Option](I1) }
trait I1 {
type I0[-I1] = I0[I1]
val I1: I1[Int, Int] = sys.error("")
}
class I1[I1 <: I1[I1], I1 <: I1[I1], I1](I1: I1[I0], I1: I1) extends I0[I1, I1] {
def size: I0[I1] = new I1[I1]
def I0[I1 <: Any](I1: I0): Unit =
I0.I1(I1)
}
object I1 {
def I1[I1, I0](I1: I1[I0]): I1[I0, I0]] = I1 match {
case I1(I1) =>
case _ => true
case _: Some[I1] => I0.I1.I1
def I1: I0[I0] => Unit =
I0 match {
case None =>
return 1
case _ => None
}
println(I1 +  + I1)
}
trait I1 {
type I0[I1] = List[I1 { type I1 <: I0[I1] } = null;
val I1: I1[I0, I1] = null
}