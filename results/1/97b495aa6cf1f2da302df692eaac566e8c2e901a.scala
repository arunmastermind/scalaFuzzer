class I0 {
sealed trait I0
}
trait I2 {
object I2 extends I0
object I2
val I2 = null
val I2: I0.type = I2
val I2: I0.I0 = new I2, { def I2 = "" }
case class I2(I2: I2) extends I2 {
abstract class I0 extends I2.map(I2.I2);
case val I0: I2;
type I2 <: I2;
trait I2 extends i1 {
def i1
}
val I2: I0 = null;
private var I2: I2;
def i1(i1: I2.I2) = I2 def I2(i1: I0): I2 <: I2.I2
}
object i1 extends I0 {
private val I0: Int = 1 }
}
package class I2() {
type i1 <: I0;
val I2: I2;
var i1: I0;
def I2(implicit i1: I0): Int = I2 *
}
import I0.I0
trait i1 {
object i1 {
class I0 }
object I2 {}
}
class I2{
}
object i1
trait I2 {
type I2[I2]
val I2: String;
type i1 = I2
}
trait I2 extends I2 {
def I2: List[I0] = I2.I2
}
abstract class I0 { I2: I2 =>
type I2 = I2.I2
}
object I2 {
import I0._ import I2.i1 { val I0 = sys.error(""); i1 }
new I0 {
trait i1 {
type I2
type I2 <: I2;
type i1 = I2 new I2
val I2 = I2;
I2 + 1 I2 <
I2;
I2 <I2>{} match
}
}
}
}