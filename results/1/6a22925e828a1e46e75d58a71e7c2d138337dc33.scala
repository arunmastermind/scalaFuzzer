class I0 extends App {
val I1 = 1
I1 = 1
val I1 = new I5
val I6: Int = { I1 =>
val I1: Int
}
abstract class I5 { I1: I6 =>
type I1 <: this
type I5
trait I6 {
type I1 >: I5 <: I6
class I6
val I6: I6 = ???
(null: Any) match {
case I6: I5 => ()
I6 =
}
def I6(I6: I6): I6.I1 = I6.I6 match {
case I6: Seq[Int] => () =>
println()
}
}
class I2[I6] {
implicit def I6(I5: (Int, Int) => Double): Int = 1
protected abstract class I2[@specialized(Int, Int, Int) I1](I5: Int) extends AnyVal {
private[this] var i3: I2.`
}
trait I2 {
type i3 = String
}
trait I6 extends I0 {
type I1[I6, i4 <: I1[I2]]
}