package I0;
trait I0 {
case class I1[i4]()
}
package I0 {
class I0
object i4 {
def i4(i4: I1): i4 = i4
}
val i4: I0[Any] = new I0[String]
val i4: List[_] = i4[_]
implicit val i4: i4[I1] = new I0[Int] {}
object i4 {
def i4: i4.i4 = ???
}
object i4 {
def I1(I1: I2, I2: Int) = ((i4, I1))
}
import I1.Serializable {
case _: AnyRef =>
i4
}
}
class I2 {
val I1: i4[Int]
}
trait I2[i4] {
def i4 = this
def i4[i4, i4[_]](I1: I1, i4: I2[i4, I1, i4, i3.i4, i3, i4, i4, i4, i4, i4, i4, i4, i4, i4, i4, I1, i3, i4, i4, i4, i4, i4, i4, i4, i4, i4, i4]: I2[i3, i4, i4, i4, i4, i4 <: i4, i4, i4, I2, i3, i4, i4, i4, i4, i4, i4, i4, i3, i4, i4, i4, i4, i4, I2, i4, i4, i4, i4[I1[_, Any]: i4[i4, i4, I1])
}
class I1 extends I0[Int, i4] with i4[Int]
object I1 extends i4[String]
object i3 extends i4[String]
object i3 extends I2
object i4 extends i4[I1[_]]
class I1
case class i3()
case object I1 extends I0[I1
object i4 extends super[i4[_]]
implicitly[type[Int]]
def i3[i4[_]]: I1[i4] = I1
val i3: I0[I1, i4, i4, Nothing with Any] = ???
import I1.I1 #:: I1 =>
}